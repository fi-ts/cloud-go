// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package project

import (
	"github.com/fi-ts/cloud-go/api/client/project"
	"github.com/go-openapi/runtime"
	mock "github.com/stretchr/testify/mock"
)

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

type ClientService_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientService) EXPECT() *ClientService_Expecter {
	return &ClientService_Expecter{mock: &_m.Mock}
}

// CreateMachineReservation provides a mock function for the type ClientService
func (_mock *ClientService) CreateMachineReservation(params *project.CreateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.CreateMachineReservationCreated, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateMachineReservation")
	}

	var r0 *project.CreateMachineReservationCreated
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.CreateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.CreateMachineReservationCreated, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.CreateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.CreateMachineReservationCreated); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.CreateMachineReservationCreated)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.CreateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_CreateMachineReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMachineReservation'
type ClientService_CreateMachineReservation_Call struct {
	*mock.Call
}

// CreateMachineReservation is a helper method to define mock.On call
//   - params *project.CreateMachineReservationParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) CreateMachineReservation(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_CreateMachineReservation_Call {
	return &ClientService_CreateMachineReservation_Call{Call: _e.mock.On("CreateMachineReservation",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_CreateMachineReservation_Call) Run(run func(params *project.CreateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_CreateMachineReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.CreateMachineReservationParams
		if args[0] != nil {
			arg0 = args[0].(*project.CreateMachineReservationParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_CreateMachineReservation_Call) Return(createMachineReservationCreated *project.CreateMachineReservationCreated, err error) *ClientService_CreateMachineReservation_Call {
	_c.Call.Return(createMachineReservationCreated, err)
	return _c
}

func (_c *ClientService_CreateMachineReservation_Call) RunAndReturn(run func(params *project.CreateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.CreateMachineReservationCreated, error)) *ClientService_CreateMachineReservation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function for the type ClientService
func (_mock *ClientService) CreateProject(params *project.CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.CreateProjectCreated, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *project.CreateProjectCreated
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.CreateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.CreateProjectCreated, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.CreateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.CreateProjectCreated); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.CreateProjectCreated)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.CreateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type ClientService_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - params *project.CreateProjectParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) CreateProject(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_CreateProject_Call {
	return &ClientService_CreateProject_Call{Call: _e.mock.On("CreateProject",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_CreateProject_Call) Run(run func(params *project.CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.CreateProjectParams
		if args[0] != nil {
			arg0 = args[0].(*project.CreateProjectParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_CreateProject_Call) Return(createProjectCreated *project.CreateProjectCreated, err error) *ClientService_CreateProject_Call {
	_c.Call.Return(createProjectCreated, err)
	return _c
}

func (_c *ClientService_CreateProject_Call) RunAndReturn(run func(params *project.CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.CreateProjectCreated, error)) *ClientService_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMachineReservation provides a mock function for the type ClientService
func (_mock *ClientService) DeleteMachineReservation(params *project.DeleteMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.DeleteMachineReservationOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteMachineReservation")
	}

	var r0 *project.DeleteMachineReservationOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.DeleteMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.DeleteMachineReservationOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.DeleteMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.DeleteMachineReservationOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.DeleteMachineReservationOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.DeleteMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_DeleteMachineReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMachineReservation'
type ClientService_DeleteMachineReservation_Call struct {
	*mock.Call
}

// DeleteMachineReservation is a helper method to define mock.On call
//   - params *project.DeleteMachineReservationParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) DeleteMachineReservation(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_DeleteMachineReservation_Call {
	return &ClientService_DeleteMachineReservation_Call{Call: _e.mock.On("DeleteMachineReservation",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_DeleteMachineReservation_Call) Run(run func(params *project.DeleteMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_DeleteMachineReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.DeleteMachineReservationParams
		if args[0] != nil {
			arg0 = args[0].(*project.DeleteMachineReservationParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_DeleteMachineReservation_Call) Return(deleteMachineReservationOK *project.DeleteMachineReservationOK, err error) *ClientService_DeleteMachineReservation_Call {
	_c.Call.Return(deleteMachineReservationOK, err)
	return _c
}

func (_c *ClientService_DeleteMachineReservation_Call) RunAndReturn(run func(params *project.DeleteMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.DeleteMachineReservationOK, error)) *ClientService_DeleteMachineReservation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function for the type ClientService
func (_mock *ClientService) DeleteProject(params *project.DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.DeleteProjectOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *project.DeleteProjectOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.DeleteProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.DeleteProjectOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.DeleteProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.DeleteProjectOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.DeleteProjectOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.DeleteProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type ClientService_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - params *project.DeleteProjectParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) DeleteProject(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_DeleteProject_Call {
	return &ClientService_DeleteProject_Call{Call: _e.mock.On("DeleteProject",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_DeleteProject_Call) Run(run func(params *project.DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.DeleteProjectParams
		if args[0] != nil {
			arg0 = args[0].(*project.DeleteProjectParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_DeleteProject_Call) Return(deleteProjectOK *project.DeleteProjectOK, err error) *ClientService_DeleteProject_Call {
	_c.Call.Return(deleteProjectOK, err)
	return _c
}

func (_c *ClientService_DeleteProject_Call) RunAndReturn(run func(params *project.DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.DeleteProjectOK, error)) *ClientService_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// FindProject provides a mock function for the type ClientService
func (_mock *ClientService) FindProject(params *project.FindProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.FindProjectOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FindProject")
	}

	var r0 *project.FindProjectOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.FindProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.FindProjectOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.FindProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.FindProjectOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.FindProjectOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.FindProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_FindProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindProject'
type ClientService_FindProject_Call struct {
	*mock.Call
}

// FindProject is a helper method to define mock.On call
//   - params *project.FindProjectParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) FindProject(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_FindProject_Call {
	return &ClientService_FindProject_Call{Call: _e.mock.On("FindProject",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_FindProject_Call) Run(run func(params *project.FindProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_FindProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.FindProjectParams
		if args[0] != nil {
			arg0 = args[0].(*project.FindProjectParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_FindProject_Call) Return(findProjectOK *project.FindProjectOK, err error) *ClientService_FindProject_Call {
	_c.Call.Return(findProjectOK, err)
	return _c
}

func (_c *ClientService_FindProject_Call) RunAndReturn(run func(params *project.FindProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.FindProjectOK, error)) *ClientService_FindProject_Call {
	_c.Call.Return(run)
	return _c
}

// FindProjects provides a mock function for the type ClientService
func (_mock *ClientService) FindProjects(params *project.FindProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.FindProjectsOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FindProjects")
	}

	var r0 *project.FindProjectsOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.FindProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.FindProjectsOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.FindProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.FindProjectsOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.FindProjectsOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.FindProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_FindProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindProjects'
type ClientService_FindProjects_Call struct {
	*mock.Call
}

// FindProjects is a helper method to define mock.On call
//   - params *project.FindProjectsParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) FindProjects(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_FindProjects_Call {
	return &ClientService_FindProjects_Call{Call: _e.mock.On("FindProjects",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_FindProjects_Call) Run(run func(params *project.FindProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_FindProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.FindProjectsParams
		if args[0] != nil {
			arg0 = args[0].(*project.FindProjectsParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_FindProjects_Call) Return(findProjectsOK *project.FindProjectsOK, err error) *ClientService_FindProjects_Call {
	_c.Call.Return(findProjectsOK, err)
	return _c
}

func (_c *ClientService_FindProjects_Call) RunAndReturn(run func(params *project.FindProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.FindProjectsOK, error)) *ClientService_FindProjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetMachineReservation provides a mock function for the type ClientService
func (_mock *ClientService) GetMachineReservation(params *project.GetMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.GetMachineReservationOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetMachineReservation")
	}

	var r0 *project.GetMachineReservationOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.GetMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.GetMachineReservationOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.GetMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.GetMachineReservationOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.GetMachineReservationOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.GetMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_GetMachineReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMachineReservation'
type ClientService_GetMachineReservation_Call struct {
	*mock.Call
}

// GetMachineReservation is a helper method to define mock.On call
//   - params *project.GetMachineReservationParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) GetMachineReservation(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_GetMachineReservation_Call {
	return &ClientService_GetMachineReservation_Call{Call: _e.mock.On("GetMachineReservation",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_GetMachineReservation_Call) Run(run func(params *project.GetMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_GetMachineReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.GetMachineReservationParams
		if args[0] != nil {
			arg0 = args[0].(*project.GetMachineReservationParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_GetMachineReservation_Call) Return(getMachineReservationOK *project.GetMachineReservationOK, err error) *ClientService_GetMachineReservation_Call {
	_c.Call.Return(getMachineReservationOK, err)
	return _c
}

func (_c *ClientService_GetMachineReservation_Call) RunAndReturn(run func(params *project.GetMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.GetMachineReservationOK, error)) *ClientService_GetMachineReservation_Call {
	_c.Call.Return(run)
	return _c
}

// ListMachineReservations provides a mock function for the type ClientService
func (_mock *ClientService) ListMachineReservations(params *project.ListMachineReservationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.ListMachineReservationsOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListMachineReservations")
	}

	var r0 *project.ListMachineReservationsOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.ListMachineReservationsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.ListMachineReservationsOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.ListMachineReservationsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.ListMachineReservationsOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.ListMachineReservationsOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.ListMachineReservationsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ListMachineReservations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMachineReservations'
type ClientService_ListMachineReservations_Call struct {
	*mock.Call
}

// ListMachineReservations is a helper method to define mock.On call
//   - params *project.ListMachineReservationsParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) ListMachineReservations(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ListMachineReservations_Call {
	return &ClientService_ListMachineReservations_Call{Call: _e.mock.On("ListMachineReservations",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ListMachineReservations_Call) Run(run func(params *project.ListMachineReservationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_ListMachineReservations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.ListMachineReservationsParams
		if args[0] != nil {
			arg0 = args[0].(*project.ListMachineReservationsParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ListMachineReservations_Call) Return(listMachineReservationsOK *project.ListMachineReservationsOK, err error) *ClientService_ListMachineReservations_Call {
	_c.Call.Return(listMachineReservationsOK, err)
	return _c
}

func (_c *ClientService_ListMachineReservations_Call) RunAndReturn(run func(params *project.ListMachineReservationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.ListMachineReservationsOK, error)) *ClientService_ListMachineReservations_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function for the type ClientService
func (_mock *ClientService) ListProjects(params *project.ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.ListProjectsOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 *project.ListProjectsOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.ListProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.ListProjectsOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.ListProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.ListProjectsOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.ListProjectsOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.ListProjectsParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type ClientService_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - params *project.ListProjectsParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) ListProjects(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ListProjects_Call {
	return &ClientService_ListProjects_Call{Call: _e.mock.On("ListProjects",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ListProjects_Call) Run(run func(params *project.ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.ListProjectsParams
		if args[0] != nil {
			arg0 = args[0].(*project.ListProjectsParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ListProjects_Call) Return(listProjectsOK *project.ListProjectsOK, err error) *ClientService_ListProjects_Call {
	_c.Call.Return(listProjectsOK, err)
	return _c
}

func (_c *ClientService_ListProjects_Call) RunAndReturn(run func(params *project.ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.ListProjectsOK, error)) *ClientService_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// MachineReservationsUsage provides a mock function for the type ClientService
func (_mock *ClientService) MachineReservationsUsage(params *project.MachineReservationsUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.MachineReservationsUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for MachineReservationsUsage")
	}

	var r0 *project.MachineReservationsUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.MachineReservationsUsageParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.MachineReservationsUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.MachineReservationsUsageParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.MachineReservationsUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.MachineReservationsUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.MachineReservationsUsageParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_MachineReservationsUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MachineReservationsUsage'
type ClientService_MachineReservationsUsage_Call struct {
	*mock.Call
}

// MachineReservationsUsage is a helper method to define mock.On call
//   - params *project.MachineReservationsUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) MachineReservationsUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_MachineReservationsUsage_Call {
	return &ClientService_MachineReservationsUsage_Call{Call: _e.mock.On("MachineReservationsUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_MachineReservationsUsage_Call) Run(run func(params *project.MachineReservationsUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_MachineReservationsUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.MachineReservationsUsageParams
		if args[0] != nil {
			arg0 = args[0].(*project.MachineReservationsUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_MachineReservationsUsage_Call) Return(machineReservationsUsageOK *project.MachineReservationsUsageOK, err error) *ClientService_MachineReservationsUsage_Call {
	_c.Call.Return(machineReservationsUsageOK, err)
	return _c
}

func (_c *ClientService_MachineReservationsUsage_Call) RunAndReturn(run func(params *project.MachineReservationsUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.MachineReservationsUsageOK, error)) *ClientService_MachineReservationsUsage_Call {
	_c.Call.Return(run)
	return _c
}

// SetTransport provides a mock function for the type ClientService
func (_mock *ClientService) SetTransport(transport runtime.ClientTransport) {
	_mock.Called(transport)
	return
}

// ClientService_SetTransport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTransport'
type ClientService_SetTransport_Call struct {
	*mock.Call
}

// SetTransport is a helper method to define mock.On call
//   - transport runtime.ClientTransport
func (_e *ClientService_Expecter) SetTransport(transport interface{}) *ClientService_SetTransport_Call {
	return &ClientService_SetTransport_Call{Call: _e.mock.On("SetTransport", transport)}
}

func (_c *ClientService_SetTransport_Call) Run(run func(transport runtime.ClientTransport)) *ClientService_SetTransport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.ClientTransport
		if args[0] != nil {
			arg0 = args[0].(runtime.ClientTransport)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClientService_SetTransport_Call) Return() *ClientService_SetTransport_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientService_SetTransport_Call) RunAndReturn(run func(transport runtime.ClientTransport)) *ClientService_SetTransport_Call {
	_c.Run(run)
	return _c
}

// UpdateMachineReservation provides a mock function for the type ClientService
func (_mock *ClientService) UpdateMachineReservation(params *project.UpdateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.UpdateMachineReservationOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UpdateMachineReservation")
	}

	var r0 *project.UpdateMachineReservationOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.UpdateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.UpdateMachineReservationOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.UpdateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.UpdateMachineReservationOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.UpdateMachineReservationOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.UpdateMachineReservationParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_UpdateMachineReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMachineReservation'
type ClientService_UpdateMachineReservation_Call struct {
	*mock.Call
}

// UpdateMachineReservation is a helper method to define mock.On call
//   - params *project.UpdateMachineReservationParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) UpdateMachineReservation(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_UpdateMachineReservation_Call {
	return &ClientService_UpdateMachineReservation_Call{Call: _e.mock.On("UpdateMachineReservation",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_UpdateMachineReservation_Call) Run(run func(params *project.UpdateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_UpdateMachineReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.UpdateMachineReservationParams
		if args[0] != nil {
			arg0 = args[0].(*project.UpdateMachineReservationParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_UpdateMachineReservation_Call) Return(updateMachineReservationOK *project.UpdateMachineReservationOK, err error) *ClientService_UpdateMachineReservation_Call {
	_c.Call.Return(updateMachineReservationOK, err)
	return _c
}

func (_c *ClientService_UpdateMachineReservation_Call) RunAndReturn(run func(params *project.UpdateMachineReservationParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.UpdateMachineReservationOK, error)) *ClientService_UpdateMachineReservation_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function for the type ClientService
func (_mock *ClientService) UpdateProject(params *project.UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.UpdateProjectOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 *project.UpdateProjectOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*project.UpdateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) (*project.UpdateProjectOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*project.UpdateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) *project.UpdateProjectOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*project.UpdateProjectOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*project.UpdateProjectParams, runtime.ClientAuthInfoWriter, ...project.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type ClientService_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - params *project.UpdateProjectParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...project.ClientOption
func (_e *ClientService_Expecter) UpdateProject(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_UpdateProject_Call {
	return &ClientService_UpdateProject_Call{Call: _e.mock.On("UpdateProject",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_UpdateProject_Call) Run(run func(params *project.UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption)) *ClientService_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *project.UpdateProjectParams
		if args[0] != nil {
			arg0 = args[0].(*project.UpdateProjectParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []project.ClientOption
		var variadicArgs []project.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]project.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_UpdateProject_Call) Return(updateProjectOK *project.UpdateProjectOK, err error) *ClientService_UpdateProject_Call {
	_c.Call.Return(updateProjectOK, err)
	return _c
}

func (_c *ClientService_UpdateProject_Call) RunAndReturn(run func(params *project.UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...project.ClientOption) (*project.UpdateProjectOK, error)) *ClientService_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}
