// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package accounting

import (
	"github.com/fi-ts/cloud-go/api/client/accounting"
	"github.com/go-openapi/runtime"
	mock "github.com/stretchr/testify/mock"
)

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

type ClientService_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientService) EXPECT() *ClientService_Expecter {
	return &ClientService_Expecter{mock: &_m.Mock}
}

// ClusterUsage provides a mock function for the type ClientService
func (_mock *ClientService) ClusterUsage(params *accounting.ClusterUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ClusterUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ClusterUsage")
	}

	var r0 *accounting.ClusterUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ClusterUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ClusterUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ClusterUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ClusterUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ClusterUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ClusterUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ClusterUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterUsage'
type ClientService_ClusterUsage_Call struct {
	*mock.Call
}

// ClusterUsage is a helper method to define mock.On call
//   - params *accounting.ClusterUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) ClusterUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ClusterUsage_Call {
	return &ClientService_ClusterUsage_Call{Call: _e.mock.On("ClusterUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ClusterUsage_Call) Run(run func(params *accounting.ClusterUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_ClusterUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ClusterUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ClusterUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ClusterUsage_Call) Return(clusterUsageOK *accounting.ClusterUsageOK, err error) *ClientService_ClusterUsage_Call {
	_c.Call.Return(clusterUsageOK, err)
	return _c
}

func (_c *ClientService_ClusterUsage_Call) RunAndReturn(run func(params *accounting.ClusterUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ClusterUsageOK, error)) *ClientService_ClusterUsage_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) ClusterUsageCSV(params *accounting.ClusterUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ClusterUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ClusterUsageCSV")
	}

	var r0 *accounting.ClusterUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ClusterUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ClusterUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ClusterUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ClusterUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ClusterUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ClusterUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ClusterUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterUsageCSV'
type ClientService_ClusterUsageCSV_Call struct {
	*mock.Call
}

// ClusterUsageCSV is a helper method to define mock.On call
//   - params *accounting.ClusterUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) ClusterUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ClusterUsageCSV_Call {
	return &ClientService_ClusterUsageCSV_Call{Call: _e.mock.On("ClusterUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ClusterUsageCSV_Call) Run(run func(params *accounting.ClusterUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_ClusterUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ClusterUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ClusterUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ClusterUsageCSV_Call) Return(clusterUsageCSVOK *accounting.ClusterUsageCSVOK, err error) *ClientService_ClusterUsageCSV_Call {
	_c.Call.Return(clusterUsageCSVOK, err)
	return _c
}

func (_c *ClientService_ClusterUsageCSV_Call) RunAndReturn(run func(params *accounting.ClusterUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ClusterUsageCSVOK, error)) *ClientService_ClusterUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerUsage provides a mock function for the type ClientService
func (_mock *ClientService) ContainerUsage(params *accounting.ContainerUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ContainerUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ContainerUsage")
	}

	var r0 *accounting.ContainerUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ContainerUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ContainerUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ContainerUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ContainerUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ContainerUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ContainerUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ContainerUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerUsage'
type ClientService_ContainerUsage_Call struct {
	*mock.Call
}

// ContainerUsage is a helper method to define mock.On call
//   - params *accounting.ContainerUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) ContainerUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ContainerUsage_Call {
	return &ClientService_ContainerUsage_Call{Call: _e.mock.On("ContainerUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ContainerUsage_Call) Run(run func(params *accounting.ContainerUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_ContainerUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ContainerUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ContainerUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ContainerUsage_Call) Return(containerUsageOK *accounting.ContainerUsageOK, err error) *ClientService_ContainerUsage_Call {
	_c.Call.Return(containerUsageOK, err)
	return _c
}

func (_c *ClientService_ContainerUsage_Call) RunAndReturn(run func(params *accounting.ContainerUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ContainerUsageOK, error)) *ClientService_ContainerUsage_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) ContainerUsageCSV(params *accounting.ContainerUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ContainerUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ContainerUsageCSV")
	}

	var r0 *accounting.ContainerUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ContainerUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ContainerUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ContainerUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ContainerUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ContainerUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ContainerUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ContainerUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerUsageCSV'
type ClientService_ContainerUsageCSV_Call struct {
	*mock.Call
}

// ContainerUsageCSV is a helper method to define mock.On call
//   - params *accounting.ContainerUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) ContainerUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ContainerUsageCSV_Call {
	return &ClientService_ContainerUsageCSV_Call{Call: _e.mock.On("ContainerUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ContainerUsageCSV_Call) Run(run func(params *accounting.ContainerUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_ContainerUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ContainerUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ContainerUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ContainerUsageCSV_Call) Return(containerUsageCSVOK *accounting.ContainerUsageCSVOK, err error) *ClientService_ContainerUsageCSV_Call {
	_c.Call.Return(containerUsageCSVOK, err)
	return _c
}

func (_c *ClientService_ContainerUsageCSV_Call) RunAndReturn(run func(params *accounting.ContainerUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ContainerUsageCSVOK, error)) *ClientService_ContainerUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// IPUsage provides a mock function for the type ClientService
func (_mock *ClientService) IPUsage(params *accounting.IPUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.IPUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for IPUsage")
	}

	var r0 *accounting.IPUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.IPUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.IPUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.IPUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.IPUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.IPUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.IPUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_IPUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPUsage'
type ClientService_IPUsage_Call struct {
	*mock.Call
}

// IPUsage is a helper method to define mock.On call
//   - params *accounting.IPUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) IPUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_IPUsage_Call {
	return &ClientService_IPUsage_Call{Call: _e.mock.On("IPUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_IPUsage_Call) Run(run func(params *accounting.IPUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_IPUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.IPUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.IPUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_IPUsage_Call) Return(iPUsageOK *accounting.IPUsageOK, err error) *ClientService_IPUsage_Call {
	_c.Call.Return(iPUsageOK, err)
	return _c
}

func (_c *ClientService_IPUsage_Call) RunAndReturn(run func(params *accounting.IPUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.IPUsageOK, error)) *ClientService_IPUsage_Call {
	_c.Call.Return(run)
	return _c
}

// IPUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) IPUsageCSV(params *accounting.IPUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.IPUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for IPUsageCSV")
	}

	var r0 *accounting.IPUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.IPUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.IPUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.IPUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.IPUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.IPUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.IPUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_IPUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPUsageCSV'
type ClientService_IPUsageCSV_Call struct {
	*mock.Call
}

// IPUsageCSV is a helper method to define mock.On call
//   - params *accounting.IPUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) IPUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_IPUsageCSV_Call {
	return &ClientService_IPUsageCSV_Call{Call: _e.mock.On("IPUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_IPUsageCSV_Call) Run(run func(params *accounting.IPUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_IPUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.IPUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.IPUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_IPUsageCSV_Call) Return(iPUsageCSVOK *accounting.IPUsageCSVOK, err error) *ClientService_IPUsageCSV_Call {
	_c.Call.Return(iPUsageCSVOK, err)
	return _c
}

func (_c *ClientService_IPUsageCSV_Call) RunAndReturn(run func(params *accounting.IPUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.IPUsageCSVOK, error)) *ClientService_IPUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// MachineReservationUsage provides a mock function for the type ClientService
func (_mock *ClientService) MachineReservationUsage(params *accounting.MachineReservationUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.MachineReservationUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for MachineReservationUsage")
	}

	var r0 *accounting.MachineReservationUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.MachineReservationUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.MachineReservationUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.MachineReservationUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.MachineReservationUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.MachineReservationUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.MachineReservationUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_MachineReservationUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MachineReservationUsage'
type ClientService_MachineReservationUsage_Call struct {
	*mock.Call
}

// MachineReservationUsage is a helper method to define mock.On call
//   - params *accounting.MachineReservationUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) MachineReservationUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_MachineReservationUsage_Call {
	return &ClientService_MachineReservationUsage_Call{Call: _e.mock.On("MachineReservationUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_MachineReservationUsage_Call) Run(run func(params *accounting.MachineReservationUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_MachineReservationUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.MachineReservationUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.MachineReservationUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_MachineReservationUsage_Call) Return(machineReservationUsageOK *accounting.MachineReservationUsageOK, err error) *ClientService_MachineReservationUsage_Call {
	_c.Call.Return(machineReservationUsageOK, err)
	return _c
}

func (_c *ClientService_MachineReservationUsage_Call) RunAndReturn(run func(params *accounting.MachineReservationUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.MachineReservationUsageOK, error)) *ClientService_MachineReservationUsage_Call {
	_c.Call.Return(run)
	return _c
}

// MachineUsage provides a mock function for the type ClientService
func (_mock *ClientService) MachineUsage(params *accounting.MachineUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.MachineUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for MachineUsage")
	}

	var r0 *accounting.MachineUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.MachineUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.MachineUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.MachineUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.MachineUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.MachineUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.MachineUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_MachineUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MachineUsage'
type ClientService_MachineUsage_Call struct {
	*mock.Call
}

// MachineUsage is a helper method to define mock.On call
//   - params *accounting.MachineUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) MachineUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_MachineUsage_Call {
	return &ClientService_MachineUsage_Call{Call: _e.mock.On("MachineUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_MachineUsage_Call) Run(run func(params *accounting.MachineUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_MachineUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.MachineUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.MachineUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_MachineUsage_Call) Return(machineUsageOK *accounting.MachineUsageOK, err error) *ClientService_MachineUsage_Call {
	_c.Call.Return(machineUsageOK, err)
	return _c
}

func (_c *ClientService_MachineUsage_Call) RunAndReturn(run func(params *accounting.MachineUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.MachineUsageOK, error)) *ClientService_MachineUsage_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkUsage provides a mock function for the type ClientService
func (_mock *ClientService) NetworkUsage(params *accounting.NetworkUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.NetworkUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for NetworkUsage")
	}

	var r0 *accounting.NetworkUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.NetworkUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.NetworkUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.NetworkUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.NetworkUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.NetworkUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.NetworkUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_NetworkUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkUsage'
type ClientService_NetworkUsage_Call struct {
	*mock.Call
}

// NetworkUsage is a helper method to define mock.On call
//   - params *accounting.NetworkUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) NetworkUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_NetworkUsage_Call {
	return &ClientService_NetworkUsage_Call{Call: _e.mock.On("NetworkUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_NetworkUsage_Call) Run(run func(params *accounting.NetworkUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_NetworkUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.NetworkUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.NetworkUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_NetworkUsage_Call) Return(networkUsageOK *accounting.NetworkUsageOK, err error) *ClientService_NetworkUsage_Call {
	_c.Call.Return(networkUsageOK, err)
	return _c
}

func (_c *ClientService_NetworkUsage_Call) RunAndReturn(run func(params *accounting.NetworkUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.NetworkUsageOK, error)) *ClientService_NetworkUsage_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) NetworkUsageCSV(params *accounting.NetworkUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.NetworkUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for NetworkUsageCSV")
	}

	var r0 *accounting.NetworkUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.NetworkUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.NetworkUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.NetworkUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.NetworkUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.NetworkUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.NetworkUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_NetworkUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkUsageCSV'
type ClientService_NetworkUsageCSV_Call struct {
	*mock.Call
}

// NetworkUsageCSV is a helper method to define mock.On call
//   - params *accounting.NetworkUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) NetworkUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_NetworkUsageCSV_Call {
	return &ClientService_NetworkUsageCSV_Call{Call: _e.mock.On("NetworkUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_NetworkUsageCSV_Call) Run(run func(params *accounting.NetworkUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_NetworkUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.NetworkUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.NetworkUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_NetworkUsageCSV_Call) Return(networkUsageCSVOK *accounting.NetworkUsageCSVOK, err error) *ClientService_NetworkUsageCSV_Call {
	_c.Call.Return(networkUsageCSVOK, err)
	return _c
}

func (_c *ClientService_NetworkUsageCSV_Call) RunAndReturn(run func(params *accounting.NetworkUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.NetworkUsageCSVOK, error)) *ClientService_NetworkUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// PostgresUsage provides a mock function for the type ClientService
func (_mock *ClientService) PostgresUsage(params *accounting.PostgresUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.PostgresUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PostgresUsage")
	}

	var r0 *accounting.PostgresUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.PostgresUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.PostgresUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.PostgresUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.PostgresUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.PostgresUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.PostgresUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_PostgresUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostgresUsage'
type ClientService_PostgresUsage_Call struct {
	*mock.Call
}

// PostgresUsage is a helper method to define mock.On call
//   - params *accounting.PostgresUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) PostgresUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_PostgresUsage_Call {
	return &ClientService_PostgresUsage_Call{Call: _e.mock.On("PostgresUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_PostgresUsage_Call) Run(run func(params *accounting.PostgresUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_PostgresUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.PostgresUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.PostgresUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_PostgresUsage_Call) Return(postgresUsageOK *accounting.PostgresUsageOK, err error) *ClientService_PostgresUsage_Call {
	_c.Call.Return(postgresUsageOK, err)
	return _c
}

func (_c *ClientService_PostgresUsage_Call) RunAndReturn(run func(params *accounting.PostgresUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.PostgresUsageOK, error)) *ClientService_PostgresUsage_Call {
	_c.Call.Return(run)
	return _c
}

// PostgresUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) PostgresUsageCSV(params *accounting.PostgresUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.PostgresUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PostgresUsageCSV")
	}

	var r0 *accounting.PostgresUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.PostgresUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.PostgresUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.PostgresUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.PostgresUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.PostgresUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.PostgresUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_PostgresUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostgresUsageCSV'
type ClientService_PostgresUsageCSV_Call struct {
	*mock.Call
}

// PostgresUsageCSV is a helper method to define mock.On call
//   - params *accounting.PostgresUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) PostgresUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_PostgresUsageCSV_Call {
	return &ClientService_PostgresUsageCSV_Call{Call: _e.mock.On("PostgresUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_PostgresUsageCSV_Call) Run(run func(params *accounting.PostgresUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_PostgresUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.PostgresUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.PostgresUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_PostgresUsageCSV_Call) Return(postgresUsageCSVOK *accounting.PostgresUsageCSVOK, err error) *ClientService_PostgresUsageCSV_Call {
	_c.Call.Return(postgresUsageCSVOK, err)
	return _c
}

func (_c *ClientService_PostgresUsageCSV_Call) RunAndReturn(run func(params *accounting.PostgresUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.PostgresUsageCSVOK, error)) *ClientService_PostgresUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// ProductOptionUsage provides a mock function for the type ClientService
func (_mock *ClientService) ProductOptionUsage(params *accounting.ProductOptionUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ProductOptionUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ProductOptionUsage")
	}

	var r0 *accounting.ProductOptionUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ProductOptionUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ProductOptionUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ProductOptionUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ProductOptionUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ProductOptionUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ProductOptionUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_ProductOptionUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProductOptionUsage'
type ClientService_ProductOptionUsage_Call struct {
	*mock.Call
}

// ProductOptionUsage is a helper method to define mock.On call
//   - params *accounting.ProductOptionUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) ProductOptionUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_ProductOptionUsage_Call {
	return &ClientService_ProductOptionUsage_Call{Call: _e.mock.On("ProductOptionUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_ProductOptionUsage_Call) Run(run func(params *accounting.ProductOptionUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_ProductOptionUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ProductOptionUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ProductOptionUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_ProductOptionUsage_Call) Return(productOptionUsageOK *accounting.ProductOptionUsageOK, err error) *ClientService_ProductOptionUsage_Call {
	_c.Call.Return(productOptionUsageOK, err)
	return _c
}

func (_c *ClientService_ProductOptionUsage_Call) RunAndReturn(run func(params *accounting.ProductOptionUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ProductOptionUsageOK, error)) *ClientService_ProductOptionUsage_Call {
	_c.Call.Return(run)
	return _c
}

// Projects provides a mock function for the type ClientService
func (_mock *ClientService) Projects(params *accounting.ProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ProjectsOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Projects")
	}

	var r0 *accounting.ProjectsOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.ProjectsParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.ProjectsOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.ProjectsParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.ProjectsOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ProjectsOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.ProjectsParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_Projects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Projects'
type ClientService_Projects_Call struct {
	*mock.Call
}

// Projects is a helper method to define mock.On call
//   - params *accounting.ProjectsParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) Projects(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_Projects_Call {
	return &ClientService_Projects_Call{Call: _e.mock.On("Projects",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_Projects_Call) Run(run func(params *accounting.ProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_Projects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.ProjectsParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.ProjectsParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_Projects_Call) Return(projectsOK *accounting.ProjectsOK, err error) *ClientService_Projects_Call {
	_c.Call.Return(projectsOK, err)
	return _c
}

func (_c *ClientService_Projects_Call) RunAndReturn(run func(params *accounting.ProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.ProjectsOK, error)) *ClientService_Projects_Call {
	_c.Call.Return(run)
	return _c
}

// S3Usage provides a mock function for the type ClientService
func (_mock *ClientService) S3Usage(params *accounting.S3UsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.S3UsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for S3Usage")
	}

	var r0 *accounting.S3UsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.S3UsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.S3UsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.S3UsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.S3UsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.S3UsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.S3UsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_S3Usage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'S3Usage'
type ClientService_S3Usage_Call struct {
	*mock.Call
}

// S3Usage is a helper method to define mock.On call
//   - params *accounting.S3UsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) S3Usage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_S3Usage_Call {
	return &ClientService_S3Usage_Call{Call: _e.mock.On("S3Usage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_S3Usage_Call) Run(run func(params *accounting.S3UsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_S3Usage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.S3UsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.S3UsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_S3Usage_Call) Return(s3UsageOK *accounting.S3UsageOK, err error) *ClientService_S3Usage_Call {
	_c.Call.Return(s3UsageOK, err)
	return _c
}

func (_c *ClientService_S3Usage_Call) RunAndReturn(run func(params *accounting.S3UsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.S3UsageOK, error)) *ClientService_S3Usage_Call {
	_c.Call.Return(run)
	return _c
}

// S3UsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) S3UsageCSV(params *accounting.S3UsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.S3UsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for S3UsageCSV")
	}

	var r0 *accounting.S3UsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.S3UsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.S3UsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.S3UsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.S3UsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.S3UsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.S3UsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_S3UsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'S3UsageCSV'
type ClientService_S3UsageCSV_Call struct {
	*mock.Call
}

// S3UsageCSV is a helper method to define mock.On call
//   - params *accounting.S3UsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) S3UsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_S3UsageCSV_Call {
	return &ClientService_S3UsageCSV_Call{Call: _e.mock.On("S3UsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_S3UsageCSV_Call) Run(run func(params *accounting.S3UsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_S3UsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.S3UsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.S3UsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_S3UsageCSV_Call) Return(s3UsageCSVOK *accounting.S3UsageCSVOK, err error) *ClientService_S3UsageCSV_Call {
	_c.Call.Return(s3UsageCSVOK, err)
	return _c
}

func (_c *ClientService_S3UsageCSV_Call) RunAndReturn(run func(params *accounting.S3UsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.S3UsageCSVOK, error)) *ClientService_S3UsageCSV_Call {
	_c.Call.Return(run)
	return _c
}

// SetTransport provides a mock function for the type ClientService
func (_mock *ClientService) SetTransport(transport runtime.ClientTransport) {
	_mock.Called(transport)
	return
}

// ClientService_SetTransport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTransport'
type ClientService_SetTransport_Call struct {
	*mock.Call
}

// SetTransport is a helper method to define mock.On call
//   - transport runtime.ClientTransport
func (_e *ClientService_Expecter) SetTransport(transport interface{}) *ClientService_SetTransport_Call {
	return &ClientService_SetTransport_Call{Call: _e.mock.On("SetTransport", transport)}
}

func (_c *ClientService_SetTransport_Call) Run(run func(transport runtime.ClientTransport)) *ClientService_SetTransport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.ClientTransport
		if args[0] != nil {
			arg0 = args[0].(runtime.ClientTransport)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClientService_SetTransport_Call) Return() *ClientService_SetTransport_Call {
	_c.Call.Return()
	return _c
}

func (_c *ClientService_SetTransport_Call) RunAndReturn(run func(transport runtime.ClientTransport)) *ClientService_SetTransport_Call {
	_c.Run(run)
	return _c
}

// VolumeUsage provides a mock function for the type ClientService
func (_mock *ClientService) VolumeUsage(params *accounting.VolumeUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.VolumeUsageOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for VolumeUsage")
	}

	var r0 *accounting.VolumeUsageOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.VolumeUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.VolumeUsageOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.VolumeUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.VolumeUsageOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.VolumeUsageOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.VolumeUsageParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_VolumeUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VolumeUsage'
type ClientService_VolumeUsage_Call struct {
	*mock.Call
}

// VolumeUsage is a helper method to define mock.On call
//   - params *accounting.VolumeUsageParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) VolumeUsage(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_VolumeUsage_Call {
	return &ClientService_VolumeUsage_Call{Call: _e.mock.On("VolumeUsage",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_VolumeUsage_Call) Run(run func(params *accounting.VolumeUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_VolumeUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.VolumeUsageParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.VolumeUsageParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_VolumeUsage_Call) Return(volumeUsageOK *accounting.VolumeUsageOK, err error) *ClientService_VolumeUsage_Call {
	_c.Call.Return(volumeUsageOK, err)
	return _c
}

func (_c *ClientService_VolumeUsage_Call) RunAndReturn(run func(params *accounting.VolumeUsageParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.VolumeUsageOK, error)) *ClientService_VolumeUsage_Call {
	_c.Call.Return(run)
	return _c
}

// VolumeUsageCSV provides a mock function for the type ClientService
func (_mock *ClientService) VolumeUsageCSV(params *accounting.VolumeUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.VolumeUsageCSVOK, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(params, authInfo, opts)
	} else {
		tmpRet = _mock.Called(params, authInfo)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for VolumeUsageCSV")
	}

	var r0 *accounting.VolumeUsageCSVOK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*accounting.VolumeUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) (*accounting.VolumeUsageCSVOK, error)); ok {
		return returnFunc(params, authInfo, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*accounting.VolumeUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) *accounting.VolumeUsageCSVOK); ok {
		r0 = returnFunc(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.VolumeUsageCSVOK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*accounting.VolumeUsageCSVParams, runtime.ClientAuthInfoWriter, ...accounting.ClientOption) error); ok {
		r1 = returnFunc(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClientService_VolumeUsageCSV_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VolumeUsageCSV'
type ClientService_VolumeUsageCSV_Call struct {
	*mock.Call
}

// VolumeUsageCSV is a helper method to define mock.On call
//   - params *accounting.VolumeUsageCSVParams
//   - authInfo runtime.ClientAuthInfoWriter
//   - opts ...accounting.ClientOption
func (_e *ClientService_Expecter) VolumeUsageCSV(params interface{}, authInfo interface{}, opts ...interface{}) *ClientService_VolumeUsageCSV_Call {
	return &ClientService_VolumeUsageCSV_Call{Call: _e.mock.On("VolumeUsageCSV",
		append([]interface{}{params, authInfo}, opts...)...)}
}

func (_c *ClientService_VolumeUsageCSV_Call) Run(run func(params *accounting.VolumeUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption)) *ClientService_VolumeUsageCSV_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *accounting.VolumeUsageCSVParams
		if args[0] != nil {
			arg0 = args[0].(*accounting.VolumeUsageCSVParams)
		}
		var arg1 runtime.ClientAuthInfoWriter
		if args[1] != nil {
			arg1 = args[1].(runtime.ClientAuthInfoWriter)
		}
		var arg2 []accounting.ClientOption
		var variadicArgs []accounting.ClientOption
		if len(args) > 2 {
			variadicArgs = args[2].([]accounting.ClientOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ClientService_VolumeUsageCSV_Call) Return(volumeUsageCSVOK *accounting.VolumeUsageCSVOK, err error) *ClientService_VolumeUsageCSV_Call {
	_c.Call.Return(volumeUsageCSVOK, err)
	return _c
}

func (_c *ClientService_VolumeUsageCSV_Call) RunAndReturn(run func(params *accounting.VolumeUsageCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...accounting.ClientOption) (*accounting.VolumeUsageCSVOK, error)) *ClientService_VolumeUsageCSV_Call {
	_c.Call.Return(run)
	return _c
}
